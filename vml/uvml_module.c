#line 1 "vml/uvml_module.c.src"

/*
 *****************************************************************************
 **       This file was autogenerated from a template  DO NOT EDIT!!!!      **
 **       Changes should be made to the original source (.src) file         **
 *****************************************************************************
 */

#line 1
/* -*- c -*- */

#include "Python.h"
#include "numpy/noprefix.h"
#include "numpy/ufuncobject.h"
//#include "config.h"
//#include <math.h>

#include "mkl.h"
#include "mkl_vml.h"

#include <stdio.h>

//for testing, Nop do no calculation, but print arguments
static void 
NopUnary(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    //npy_intp i;
    npy_intp is=steps[0];
    npy_intp os=steps[1];
    npy_intp n=dimensions[0];
    //char *in = args[0], *out=args[1];
    printf("NOP: dim %5d step1: %3d step2: %3d\n", (int)n, (int)is, (int)os);
}

static void 
NopBinary(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    //npy_intp i;
    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    npy_intp n=dimensions[0];
    //char *inA = args[0], *inB=args[1], *out=args[2];
    printf("NOP: dim %5d stepA: %3d stepB: %3d stepO: %3d\n", (int)n, (int)isA, (int)isB, (int)os);

}

//for comparison
static void 
dMul2(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp i;
    npy_intp is=steps[0];
    npy_intp os=steps[1];
    npy_intp n=dimensions[0];
    char *in = args[0], *out=args[1];
    for (i=0; i<n; i++) {
	*((double *)out) =  2*(*((double *)in));
	in += is;
	out += os;
    }
}

//for comparison, slightly different loop
static void
dExp2(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp i;
    npy_intp n=dimensions[0];
    double *in = (double *)args[0], *out=(double *)args[1];
    for (i=0; i<n; i++) {
	*out =  exp(*in);
	in ++;
	out ++;
    }
}


// unitary real vml functions
/* NOTE copying: if in is strided, but out not, use out for first copy
 * target. But, what happens, if in is strided, but overlaps with output
 * arguments  */

#define UNARY_FUNC(FNAME, TYPE, TYPECHAR)				\
    static void								\
    u_v##TYPECHAR##FNAME(char** args,					\
			 npy_intp *dimensions, npy_intp *steps,		\
			 void *NPY_UNUSED(func))			\
    {									\
	npy_intp n = dimensions[0];					\
	TYPE *in = (TYPE *)args[0];					\
	TYPE *out = (TYPE *)args[1];					\
	npy_intp is=steps[0];						\
	npy_intp os=steps[1];						\
	int in_packed = 0, out_packed = 0;				\
	TYPE * inwork = in;						\
	TYPE * outwork = out;						\
	if (is != sizeof(TYPE)) {					\
	    if (os == sizeof(TYPE)) {					\
		    inwork = outwork;					\
		}							\
		else {							\
		    in_packed = 1;					\
		    inwork = (TYPE *)MKL_malloc(sizeof(TYPE)*n, 16);	\
		}							\
	    v##TYPECHAR##PackI(n, in, is/sizeof(TYPE), inwork);		\
	}								\
	if (os != sizeof(TYPE)) {					\
	    out_packed = 1;						\
	    outwork = (TYPE *)MKL_malloc(sizeof(TYPE)*n, 16);		\
	}								\
	v##TYPECHAR##FNAME(n, inwork, outwork);				\
	if (out_packed) {						\
	    v##TYPECHAR##UnpackI(n, outwork, out, os/sizeof(TYPE));	\
	    MKL_free(outwork);						\
	}								\
	if (in_packed) {						\
	    MKL_free(inwork);						\
	}								\
    }									\

#define DEFINE_UNARY_FUNC_sd(FNAME)					\
    UNARY_FUNC(FNAME, float, s)						\
    UNARY_FUNC(FNAME, double, d)					\
    static PyUFuncGenericFunction FNAME##_functions[] = {u_vs##FNAME, u_vd##FNAME};

#line 127
DEFINE_UNARY_FUNC_sd(Sqr)

#line 127
DEFINE_UNARY_FUNC_sd(Abs)

#line 127
DEFINE_UNARY_FUNC_sd(Inv)

#line 127
DEFINE_UNARY_FUNC_sd(Sqrt)

#line 127
DEFINE_UNARY_FUNC_sd(InvSqrt)

#line 127
DEFINE_UNARY_FUNC_sd(Cbrt)

#line 127
DEFINE_UNARY_FUNC_sd(InvCbrt)

#line 127
DEFINE_UNARY_FUNC_sd(Pow2o3)

#line 127
DEFINE_UNARY_FUNC_sd(Pow3o2)

#line 127
DEFINE_UNARY_FUNC_sd(Exp)

#line 127
DEFINE_UNARY_FUNC_sd(Expm1)

#line 127
DEFINE_UNARY_FUNC_sd(Ln)

#line 127
DEFINE_UNARY_FUNC_sd(Log10)

#line 127
DEFINE_UNARY_FUNC_sd(Log1p)

#line 127
DEFINE_UNARY_FUNC_sd(Cos)

#line 127
DEFINE_UNARY_FUNC_sd(Sin)

#line 127
DEFINE_UNARY_FUNC_sd(Tan)

#line 127
DEFINE_UNARY_FUNC_sd(Acos)

#line 127
DEFINE_UNARY_FUNC_sd(Asin)

#line 127
DEFINE_UNARY_FUNC_sd(Atan)

#line 127
DEFINE_UNARY_FUNC_sd(Cosh)

#line 127
DEFINE_UNARY_FUNC_sd(Sinh)

#line 127
DEFINE_UNARY_FUNC_sd(Tanh)

#line 127
DEFINE_UNARY_FUNC_sd(Acosh)

#line 127
DEFINE_UNARY_FUNC_sd(Asinh)

#line 127
DEFINE_UNARY_FUNC_sd(Atanh)

#line 127
DEFINE_UNARY_FUNC_sd(Erf)

#line 127
DEFINE_UNARY_FUNC_sd(Erfc)

#line 127
DEFINE_UNARY_FUNC_sd(ErfInv)

#line 127
DEFINE_UNARY_FUNC_sd(Floor)

#line 127
DEFINE_UNARY_FUNC_sd(Ceil)

#line 127
DEFINE_UNARY_FUNC_sd(Trunc)

#line 127
DEFINE_UNARY_FUNC_sd(Round)

#line 127
DEFINE_UNARY_FUNC_sd(NearbyInt)



// unitary complex vml functions
#line 135

#line 140
static void
u_vcConj(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex8 *in = (MKL_Complex8 *)args[0];
    MKL_Complex8 *out = (MKL_Complex8 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex8* inwork = in;
    MKL_Complex8* outwork = out;

    /*
    if (is != sizeof(MKL_Complex8))
    {
	in_packed = 1;
	inwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
	vcPackI(n, in, is/sizeof(MKL_Complex8), inwork);
    }

    if (os != sizeof(MKL_Complex8))
    {
	out_packed = 1;
	outwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
    }
    */
    
    vcConj(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vcUnpackI(n, outwork, out, os/sizeof(MKL_Complex8));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

#line 140
static void
u_vzConj(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex16 *in = (MKL_Complex16 *)args[0];
    MKL_Complex16 *out = (MKL_Complex16 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex16* inwork = in;
    MKL_Complex16* outwork = out;

    /*
    if (is != sizeof(MKL_Complex16))
    {
	in_packed = 1;
	inwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
	vzPackI(n, in, is/sizeof(MKL_Complex16), inwork);
    }

    if (os != sizeof(MKL_Complex16))
    {
	out_packed = 1;
	outwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
    }
    */
    
    vzConj(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vzUnpackI(n, outwork, out, os/sizeof(MKL_Complex16));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

static PyUFuncGenericFunction Conj_functions_complex[] = {u_vcConj, u_vzConj};

#line 135

#line 140
static void
u_vcSqrt(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex8 *in = (MKL_Complex8 *)args[0];
    MKL_Complex8 *out = (MKL_Complex8 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex8* inwork = in;
    MKL_Complex8* outwork = out;

    /*
    if (is != sizeof(MKL_Complex8))
    {
	in_packed = 1;
	inwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
	vcPackI(n, in, is/sizeof(MKL_Complex8), inwork);
    }

    if (os != sizeof(MKL_Complex8))
    {
	out_packed = 1;
	outwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
    }
    */
    
    vcSqrt(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vcUnpackI(n, outwork, out, os/sizeof(MKL_Complex8));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

#line 140
static void
u_vzSqrt(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex16 *in = (MKL_Complex16 *)args[0];
    MKL_Complex16 *out = (MKL_Complex16 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex16* inwork = in;
    MKL_Complex16* outwork = out;

    /*
    if (is != sizeof(MKL_Complex16))
    {
	in_packed = 1;
	inwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
	vzPackI(n, in, is/sizeof(MKL_Complex16), inwork);
    }

    if (os != sizeof(MKL_Complex16))
    {
	out_packed = 1;
	outwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
    }
    */
    
    vzSqrt(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vzUnpackI(n, outwork, out, os/sizeof(MKL_Complex16));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

static PyUFuncGenericFunction Sqrt_functions_complex[] = {u_vcSqrt, u_vzSqrt};

#line 135

#line 140
static void
u_vcExp(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex8 *in = (MKL_Complex8 *)args[0];
    MKL_Complex8 *out = (MKL_Complex8 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex8* inwork = in;
    MKL_Complex8* outwork = out;

    /*
    if (is != sizeof(MKL_Complex8))
    {
	in_packed = 1;
	inwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
	vcPackI(n, in, is/sizeof(MKL_Complex8), inwork);
    }

    if (os != sizeof(MKL_Complex8))
    {
	out_packed = 1;
	outwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
    }
    */
    
    vcExp(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vcUnpackI(n, outwork, out, os/sizeof(MKL_Complex8));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

#line 140
static void
u_vzExp(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex16 *in = (MKL_Complex16 *)args[0];
    MKL_Complex16 *out = (MKL_Complex16 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex16* inwork = in;
    MKL_Complex16* outwork = out;

    /*
    if (is != sizeof(MKL_Complex16))
    {
	in_packed = 1;
	inwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
	vzPackI(n, in, is/sizeof(MKL_Complex16), inwork);
    }

    if (os != sizeof(MKL_Complex16))
    {
	out_packed = 1;
	outwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
    }
    */
    
    vzExp(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vzUnpackI(n, outwork, out, os/sizeof(MKL_Complex16));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

static PyUFuncGenericFunction Exp_functions_complex[] = {u_vcExp, u_vzExp};

#line 135

#line 140
static void
u_vcLn(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex8 *in = (MKL_Complex8 *)args[0];
    MKL_Complex8 *out = (MKL_Complex8 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex8* inwork = in;
    MKL_Complex8* outwork = out;

    /*
    if (is != sizeof(MKL_Complex8))
    {
	in_packed = 1;
	inwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
	vcPackI(n, in, is/sizeof(MKL_Complex8), inwork);
    }

    if (os != sizeof(MKL_Complex8))
    {
	out_packed = 1;
	outwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
    }
    */
    
    vcLn(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vcUnpackI(n, outwork, out, os/sizeof(MKL_Complex8));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

#line 140
static void
u_vzLn(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex16 *in = (MKL_Complex16 *)args[0];
    MKL_Complex16 *out = (MKL_Complex16 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex16* inwork = in;
    MKL_Complex16* outwork = out;

    /*
    if (is != sizeof(MKL_Complex16))
    {
	in_packed = 1;
	inwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
	vzPackI(n, in, is/sizeof(MKL_Complex16), inwork);
    }

    if (os != sizeof(MKL_Complex16))
    {
	out_packed = 1;
	outwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
    }
    */
    
    vzLn(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vzUnpackI(n, outwork, out, os/sizeof(MKL_Complex16));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

static PyUFuncGenericFunction Ln_functions_complex[] = {u_vcLn, u_vzLn};

#line 135

#line 140
static void
u_vcLog10(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex8 *in = (MKL_Complex8 *)args[0];
    MKL_Complex8 *out = (MKL_Complex8 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex8* inwork = in;
    MKL_Complex8* outwork = out;

    /*
    if (is != sizeof(MKL_Complex8))
    {
	in_packed = 1;
	inwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
	vcPackI(n, in, is/sizeof(MKL_Complex8), inwork);
    }

    if (os != sizeof(MKL_Complex8))
    {
	out_packed = 1;
	outwork = (MKL_Complex8 *)MKL_malloc(sizeof(MKL_Complex8)*n, 16);
    }
    */
    
    vcLog10(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vcUnpackI(n, outwork, out, os/sizeof(MKL_Complex8));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

#line 140
static void
u_vzLog10(char** args, npy_intp *dimensions, npy_intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    MKL_Complex16 *in = (MKL_Complex16 *)args[0];
    MKL_Complex16 *out = (MKL_Complex16 *)args[1];
    //npy_intp is=steps[0];
    //npy_intp os=steps[1];

    //int in_packed = 0, out_packed = 0;
    MKL_Complex16* inwork = in;
    MKL_Complex16* outwork = out;

    /*
    if (is != sizeof(MKL_Complex16))
    {
	in_packed = 1;
	inwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
	vzPackI(n, in, is/sizeof(MKL_Complex16), inwork);
    }

    if (os != sizeof(MKL_Complex16))
    {
	out_packed = 1;
	outwork = (MKL_Complex16 *)MKL_malloc(sizeof(MKL_Complex16)*n, 16);
    }
    */
    
    vzLog10(n, inwork, outwork);
    
    /*
    if (out_packed)
    {
	vzUnpackI(n, outwork, out, os/sizeof(MKL_Complex16));
	MKL_free(outwork);
    }
    
    if (in_packed)
    {
	MKL_free(inwork);
    }
    */
    
}

static PyUFuncGenericFunction Log10_functions_complex[] = {u_vcLog10, u_vzLog10};


// binary vml functions

#line 193

#line 198

static void
u_vsAdd(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsAdd(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdAdd(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdAdd(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Add_functions[] = {u_vsAdd, u_vdAdd};


#line 193

#line 198

static void
u_vsSub(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsSub(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdSub(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdSub(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Sub_functions[] = {u_vsSub, u_vdSub};


#line 193

#line 198

static void
u_vsMul(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsMul(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdMul(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdMul(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Mul_functions[] = {u_vsMul, u_vdMul};


#line 193

#line 198

static void
u_vsDiv(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsDiv(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdDiv(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdDiv(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Div_functions[] = {u_vsDiv, u_vdDiv};


#line 193

#line 198

static void
u_vsPow(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsPow(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdPow(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdPow(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Pow_functions[] = {u_vsPow, u_vdPow};


#line 193

#line 198

static void
u_vsHypot(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsHypot(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdHypot(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdHypot(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Hypot_functions[] = {u_vsHypot, u_vdHypot};


#line 193

#line 198

static void
u_vsAtan2(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    float *inA = (float *)args[0];
    float *inB = (float *)args[1];
    float *out = (float *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    float* inAwork = inA;
    float* inBwork = inB;
    float* outwork = out;

    if (isA != sizeof(float))
    {
	inA_packed = 1;
	inAwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inA, isA/sizeof(float), inAwork);
    }

    if (isB != sizeof(float))
    {
	inB_packed = 1;
	inBwork = (float *)MKL_malloc(sizeof(float)*n, 16);
	vsPackI(n, inB, isB/sizeof(float), inBwork);
    }

    if (os != sizeof(float))
    {
	out_packed = 1;
	outwork = (float *)MKL_malloc(sizeof(float)*n, 16);
    }

    vsAtan2(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vsUnpackI(n, outwork, out, os/sizeof(float));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


#line 198

static void
u_vdAtan2(char** args, intp *dimensions, intp *steps, void *NPY_UNUSED(func))
{
    npy_intp n = dimensions[0];
    double *inA = (double *)args[0];
    double *inB = (double *)args[1];
    double *out = (double *)args[2];

    npy_intp isA=steps[0];
    npy_intp isB=steps[1];
    npy_intp os=steps[2];
    
    int inA_packed = 0, inB_packed = 0, out_packed = 0;
    double* inAwork = inA;
    double* inBwork = inB;
    double* outwork = out;

    if (isA != sizeof(double))
    {
	inA_packed = 1;
	inAwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inA, isA/sizeof(double), inAwork);
    }

    if (isB != sizeof(double))
    {
	inB_packed = 1;
	inBwork = (double *)MKL_malloc(sizeof(double)*n, 16);
	vdPackI(n, inB, isB/sizeof(double), inBwork);
    }

    if (os != sizeof(double))
    {
	out_packed = 1;
	outwork = (double *)MKL_malloc(sizeof(double)*n, 16);
    }

    vdAtan2(n, inAwork, inBwork, outwork);

    if (out_packed)
    {
	vdUnpackI(n, outwork, out, os/sizeof(double));
	MKL_free(outwork);
    }
    
    if (inA_packed) { MKL_free(inAwork); }
    if (inB_packed) { MKL_free(inBwork); }

}


static PyUFuncGenericFunction Atan2_functions[] = {u_vsAtan2, u_vdAtan2};





static PyUFuncGenericFunction Nop_unary_functions[] = {NopUnary, NopUnary, NopUnary, NopUnary};
static PyUFuncGenericFunction Nop_binary_functions[] = {NopBinary, NopBinary};
static PyUFuncGenericFunction Exp2_functions[] = {dExp2};
static PyUFuncGenericFunction Mul2_functions[] = {dMul2};

static void * blank2_data[] = { (void *)NULL, (void *)NULL};
static void * blank4_data[] = { (void *)NULL, (void *)NULL, (void *)NULL, (void *)NULL};

static char DD_signatures[] = {NPY_DOUBLE, NPY_DOUBLE};
static char FF_DD_signatures[] = {NPY_FLOAT, NPY_FLOAT,
				  NPY_DOUBLE, NPY_DOUBLE};
static char CC_ZZ_signatures[] = {NPY_CFLOAT, NPY_CFLOAT,
				  NPY_CDOUBLE, NPY_CDOUBLE};
static char FFF_DDD_signatures[] = {NPY_FLOAT, NPY_FLOAT, NPY_FLOAT,
				    NPY_DOUBLE, NPY_DOUBLE, NPY_DOUBLE};

static char FF_DD_CC_ZZ_signatures[] = {NPY_FLOAT, NPY_FLOAT,
					NPY_DOUBLE, NPY_DOUBLE, 
					NPY_CFLOAT, NPY_CFLOAT,
					NPY_CDOUBLE, NPY_CDOUBLE};


static PyObject *
set_vml_accuracy_mode(PyObject *self, PyObject *args)
{
    int mode_in;
    if (!PyArg_ParseTuple(args, "i", &mode_in))
	return NULL;
    vmlSetMode((mode_in & VML_ACCURACY_MASK) | VML_ERRMODE_IGNORE );
    return Py_BuildValue("i", vmlGetMode());
    //Py_RETURN_NONE;
}

static PyObject *
set_num_threads(PyObject *self, PyObject *args)
{
    int max_num_threads;
    if (!PyArg_ParseTuple(args, "i", &max_num_threads))
	return NULL;
    
    //omp_set_num_threads(max_num_threads);
    mkl_domain_set_num_threads(max_num_threads, MKL_VML);
    Py_RETURN_NONE;
}


static PyMethodDef uvmlmethods[] = {
    {"set_vml_accuracy_mode", set_vml_accuracy_mode, METH_VARARGS, 
     "set accuracy mode for VML functions ('high', 'low', 'fast')"},
    {"set_num_threads", set_num_threads, METH_VARARGS,
     "set maximum number of threads"},

    {NULL, NULL, 0, NULL}
};

PyMODINIT_FUNC
inituvml(void)
{
    PyObject *f, *dict, *module;
    module = Py_InitModule("uvml", uvmlmethods);

    import_array();
    import_ufunc();
   
    dict = PyModule_GetDict(module);

    //unitary vml functions
    #line 303
    
    f = PyUFunc_FromFuncAndData( Sqr_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Sqr",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Sqr", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Abs_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Abs",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Abs", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Inv_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Inv",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Inv", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Sqrt_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Sqrt",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Sqrt", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( InvSqrt_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "InvSqrt",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "InvSqrt", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Cbrt_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Cbrt",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Cbrt", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( InvCbrt_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "InvCbrt",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "InvCbrt", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Pow2o3_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Pow2o3",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Pow2o3", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Pow3o2_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Pow3o2",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Pow3o2", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Exp_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Exp",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Exp", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Expm1_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Expm1",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Expm1", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Ln_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Ln",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Ln", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Log10_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Log10",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Log10", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Log1p_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Log1p",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Log1p", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Cos_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Cos",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Cos", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Sin_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Sin",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Sin", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Tan_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Tan",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Tan", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Acos_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Acos",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Acos", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Asin_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Asin",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Asin", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Atan_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Atan",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Atan", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Cosh_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Cosh",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Cosh", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Sinh_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Sinh",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Sinh", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Tanh_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Tanh",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Tanh", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Acosh_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Acosh",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Acosh", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Asinh_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Asinh",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Asinh", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Atanh_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Atanh",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Atanh", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Erf_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Erf",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Erf", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Erfc_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Erfc",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Erfc", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( ErfInv_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "ErfInv",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "ErfInv", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Floor_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Floor",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Floor", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Ceil_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Ceil",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Ceil", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Trunc_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Trunc",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Trunc", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( Round_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "Round",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Round", f);
    Py_DECREF(f);
    
#line 303
    
    f = PyUFunc_FromFuncAndData( NearbyInt_functions, 
				 blank2_data,
				 FF_DD_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "NearbyInt",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "NearbyInt", f);
    Py_DECREF(f);
    

    //binary vml functions
    #line 322
    
    f = PyUFunc_FromFuncAndData( Add_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Add",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Add", f);
    Py_DECREF(f);
    
#line 322
    
    f = PyUFunc_FromFuncAndData( Sub_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Sub",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Sub", f);
    Py_DECREF(f);
    
#line 322
    
    f = PyUFunc_FromFuncAndData( Mul_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Mul",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Mul", f);
    Py_DECREF(f);
    
#line 322
    
    f = PyUFunc_FromFuncAndData( Div_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Div",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Div", f);
    Py_DECREF(f);
    
#line 322
    
    f = PyUFunc_FromFuncAndData( Pow_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Pow",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Pow", f);
    Py_DECREF(f);
    
#line 322
    
    f = PyUFunc_FromFuncAndData( Hypot_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Hypot",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Hypot", f);
    Py_DECREF(f);
    
#line 322
    
    f = PyUFunc_FromFuncAndData( Atan2_functions, 
				 blank2_data,
				 FFF_DDD_signatures, 2,
				 2,
				 1,
				 PyUFunc_One,
				 "Atan2",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "Atan2", f);
    Py_DECREF(f);
    


    //unitary complex vml functions
    #line 342
    
    f = PyUFunc_FromFuncAndData( Conj_functions_complex, 
				 blank2_data,
				 CC_ZZ_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "cConj",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "cConj", f);
    Py_DECREF(f);
    
#line 342
    
    f = PyUFunc_FromFuncAndData( Sqrt_functions_complex, 
				 blank2_data,
				 CC_ZZ_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "cSqrt",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "cSqrt", f);
    Py_DECREF(f);
    
#line 342
    
    f = PyUFunc_FromFuncAndData( Exp_functions_complex, 
				 blank2_data,
				 CC_ZZ_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "cExp",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "cExp", f);
    Py_DECREF(f);
    
#line 342
    
    f = PyUFunc_FromFuncAndData( Ln_functions_complex, 
				 blank2_data,
				 CC_ZZ_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "cLn",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "cLn", f);
    Py_DECREF(f);
    
#line 342
    
    f = PyUFunc_FromFuncAndData( Log10_functions_complex, 
				 blank2_data,
				 CC_ZZ_signatures, 2,
				 1,
				 1,
				 PyUFunc_One,
				 "cLog10",
				 "",
				 0);
    
    PyDict_SetItemString(dict, "cLog10", f);
    Py_DECREF(f);
    


    

    //choose VML accuracy mode
    vmlSetMode(VML_LA | VML_DOUBLE_CONSISTENT | VML_ERRMODE_IGNORE);

    //reference functions
    f = PyUFunc_FromFuncAndData( Nop_unary_functions, blank4_data,
				 FF_DD_CC_ZZ_signatures, 4,
				 1, 1, PyUFunc_One,
				 "NopUnary", "do nothin", 0);
    PyDict_SetItemString(dict, "NopUnary", f);
    Py_DECREF(f);

    f = PyUFunc_FromFuncAndData( Nop_binary_functions, blank2_data,
				 FFF_DDD_signatures, 2,
				 2, 1, PyUFunc_One,
				 "NopBinary", "do nothin", 0);
    PyDict_SetItemString(dict, "NopBinary", f);
    Py_DECREF(f);

    f = PyUFunc_FromFuncAndData( Exp2_functions, blank2_data,
				 DD_signatures, 1,
				 1,
				 1,
				 PyUFunc_One,
				 "Exp2",
				 "calculate exponential",
				 0);
    PyDict_SetItemString(dict, "Exp2", f);
    Py_DECREF(f);

    f = PyUFunc_FromFuncAndData( Mul2_functions, blank2_data,
				 DD_signatures, 1,
				 1,
				 1,
				 PyUFunc_One,
				 "Mul2",
				 "calculate exponential",
				 0);
    
    PyDict_SetItemString(dict, "Mul2", f);
    Py_DECREF(f);

    
}

